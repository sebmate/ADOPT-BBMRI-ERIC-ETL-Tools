/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package de.fau.med.imi.MappingGUI;

import de.fau.med.imi.MDRPipe.MDRPipeConfiguration;
import java.awt.Color;
import java.awt.Component;
import java.awt.List;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.DefaultListCellRenderer;
import javax.swing.DefaultListModel;
import javax.swing.JFileChooser;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.ListModel;
import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;

/**
 *
 * @author matesn
 */
public class UI extends javax.swing.JFrame {

    private ArrayList<Mapping> mappings = new ArrayList<>();
    private ArrayList<String> targetTermList = new ArrayList<>();
    boolean block = false;
    private String currentFile = "";
    MappingFile mf = null;
    private String targetNsFile = "";

    /**
     * Creates new form UI
     */
    public UI() {

        try {
            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | UnsupportedLookAndFeelException ex) {
            Logger.getLogger(UI.class.getName()).log(Level.SEVERE, null, ex);
        }

        initComponents();

        String openFile = "";

        try {
            MDRPipeConfiguration conf = new MDRPipeConfiguration("default");
            openFile = MDRPipeConfiguration.getMatchingFileName();
            targetNsFile = MDRPipeConfiguration.getMdrTargetFileName();
            if (!targetNsFile.equals("")) {
                targetNsFile = "metadata/" + targetNsFile;
            }
        } catch (Exception e) {
            //e.printStackTrace();
        }

        if (!openFile.equals("")) {
            mf = new MappingFile("mappings/" + MDRPipeConfiguration.getMatchingFileName());
            currentFile = "mappings/" + MDRPipeConfiguration.getMatchingFileName();
            mappings = mf.getMappings();
            refreshSourceTerms();
            saveFileButton.setEnabled(true);
            saveAsButton.setEnabled(true);
        } else {
            //MappingFile mf = new MappingFile("");
            mappings = null;
            refreshSourceTerms();
        }

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        searchTermWindow = new javax.swing.JFrame();
        filterText = new javax.swing.JTextField();
        jLabel4 = new javax.swing.JLabel();
        jScrollPane3 = new javax.swing.JScrollPane();
        targetTerminology = new javax.swing.JList<>();
        cancelButton = new javax.swing.JButton();
        jButton2 = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        sourceTerms = new javax.swing.JList<>();
        jScrollPane2 = new javax.swing.JScrollPane();
        targetTerms = new javax.swing.JList<>();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        removeMappingButton = new javax.swing.JButton();
        findButton = new javax.swing.JButton();
        revertButton = new javax.swing.JButton();
        approveButton = new javax.swing.JButton();
        openFileButton = new javax.swing.JButton();
        saveFileButton = new javax.swing.JButton();
        logo = new javax.swing.JLabel();
        saveAsButton = new javax.swing.JButton();
        knownButton = new javax.swing.JButton();
        autoJumpCheckbox = new javax.swing.JCheckBox();
        statsButton = new javax.swing.JButton();

        searchTermWindow.setTitle("Find other term");
        searchTermWindow.setSize(new java.awt.Dimension(500, 40));

        filterText.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                filterTextActionPerformed(evt);
            }
        });
        filterText.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                filterTextKeyReleased(evt);
            }
            public void keyTyped(java.awt.event.KeyEvent evt) {
                filterTextKeyTyped(evt);
            }
        });

        jLabel4.setText("Filter:");

        targetTerminology.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                targetTerminologyMouseClicked(evt);
            }
        });
        jScrollPane3.setViewportView(targetTerminology);

        cancelButton.setText("Cancel");
        cancelButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cancelButtonActionPerformed(evt);
            }
        });

        jButton2.setText("Add to list of matches");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout searchTermWindowLayout = new javax.swing.GroupLayout(searchTermWindow.getContentPane());
        searchTermWindow.getContentPane().setLayout(searchTermWindowLayout);
        searchTermWindowLayout.setHorizontalGroup(
            searchTermWindowLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(searchTermWindowLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(searchTermWindowLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 508, Short.MAX_VALUE)
                    .addGroup(searchTermWindowLayout.createSequentialGroup()
                        .addComponent(jLabel4)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(filterText))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, searchTermWindowLayout.createSequentialGroup()
                        .addGap(0, 0, Short.MAX_VALUE)
                        .addComponent(cancelButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButton2, javax.swing.GroupLayout.PREFERRED_SIZE, 143, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );
        searchTermWindowLayout.setVerticalGroup(
            searchTermWindowLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(searchTermWindowLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(searchTermWindowLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(filterText, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel4))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 233, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(searchTermWindowLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(cancelButton)
                    .addComponent(jButton2))
                .addContainerGap())
        );

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("BBMRI-ERIC Mapping GUI");
        setLocationByPlatform(true);

        sourceTerms.addListSelectionListener(new javax.swing.event.ListSelectionListener() {
            public void valueChanged(javax.swing.event.ListSelectionEvent evt) {
                sourceTermsValueChanged(evt);
            }
        });
        jScrollPane1.setViewportView(sourceTerms);

        jScrollPane2.setViewportView(targetTerms);

        jLabel1.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        jLabel1.setText("Source item (in your data):");

        jLabel2.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        jLabel2.setText("Target item (in BBMRI):");

        removeMappingButton.setText(" Remove mapping");
        removeMappingButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                removeMappingButtonActionPerformed(evt);
            }
        });

        findButton.setText(" Find other term");
        findButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                findButtonActionPerformed(evt);
            }
        });

        revertButton.setText(" Revert to suggestion");
        revertButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                revertButtonActionPerformed(evt);
            }
        });

        approveButton.setBackground(new java.awt.Color(138, 211, 138));
        approveButton.setText(" Approve");
        approveButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                approveButtonActionPerformed(evt);
            }
        });

        openFileButton.setText(" Open");
        openFileButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                openFileButtonActionPerformed(evt);
            }
        });

        saveFileButton.setText(" Save");
        saveFileButton.setEnabled(false);
        saveFileButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveFileButtonActionPerformed(evt);
            }
        });

        logo.setIcon(new javax.swing.ImageIcon(getClass().getResource("/logo.png"))); // NOI18N

        saveAsButton.setText(" Save As ...");
        saveAsButton.setEnabled(false);
        saveAsButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveAsButtonActionPerformed(evt);
            }
        });

        knownButton.setText("Apply Known Mappings");
        knownButton.setToolTipText("");
        knownButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                knownButtonActionPerformed(evt);
            }
        });

        autoJumpCheckbox.setSelected(true);
        autoJumpCheckbox.setText("Auto jump to next entry");

        statsButton.setText(" Statistics");
        statsButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                statsButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                            .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                .addComponent(openFileButton, javax.swing.GroupLayout.PREFERRED_SIZE, 79, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(saveFileButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                            .addComponent(jLabel1, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(saveAsButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(statsButton)
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane2)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel2)
                            .addComponent(knownButton, javax.swing.GroupLayout.PREFERRED_SIZE, 166, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(logo))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGap(0, 0, Short.MAX_VALUE)
                        .addComponent(removeMappingButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(autoJumpCheckbox)
                            .addComponent(revertButton))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(findButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(approveButton, javax.swing.GroupLayout.DEFAULT_SIZE, 143, Short.MAX_VALUE))))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                    .addComponent(logo)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(openFileButton)
                            .addComponent(saveFileButton)
                            .addComponent(saveAsButton)
                            .addComponent(statsButton)
                            .addComponent(knownButton))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 35, Short.MAX_VALUE)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel2)
                            .addComponent(jLabel1))))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(removeMappingButton)
                            .addComponent(revertButton)
                            .addComponent(findButton))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(approveButton)
                            .addComponent(autoJumpCheckbox)))
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 399, Short.MAX_VALUE))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void removeMappingButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_removeMappingButtonActionPerformed
        Mapping curr = mappings.get(sourceTerms.getSelectedIndex());
        curr.setMappingTerm("");
        curr.setMappingStatus(0);
        mappings.set(sourceTerms.getSelectedIndex(), curr);
        targetTerms.clearSelection();
        refreshSourceTerms();
    }//GEN-LAST:event_removeMappingButtonActionPerformed

    private void findButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_findButtonActionPerformed

        if (targetNsFile.equals("")) {
            JOptionPane.showMessageDialog(null, "Please select the target namespace metadata file manually.", "No target metadata", JOptionPane.INFORMATION_MESSAGE);
            File workingDirectory = new File(System.getProperty("user.dir"));
            final JFileChooser fc = new JFileChooser();
            fc.setCurrentDirectory(workingDirectory);
            int returnVal = fc.showOpenDialog(UI.this);

            if (returnVal == JFileChooser.APPROVE_OPTION) {
                File file = fc.getSelectedFile();
                //This is where a real application would open the file.
                System.out.println("Opening: " + file.getName() + ".");
                targetNsFile = file.getPath();
            } else {
                System.out.println("Open command cancelled by user.");
                return;
            }
        }

        if (!targetTermList.isEmpty()) {
            targetTermList.clear();
        }
        DefaultListModel listModel = new DefaultListModel();
        try {
            BufferedReader br = new BufferedReader(new FileReader(targetNsFile));
            StringBuilder sb = new StringBuilder();
            String line = br.readLine();

            while (line != null) {
                sb.append(line);
                sb.append(System.lineSeparator());
                line = br.readLine();
                if (line != null) {
                    String[] entries = line.split("\t");
                    listModel.addElement(entries[4]);
                    targetTermList.add(entries[4]);
                }
            }
            sb.append(System.lineSeparator());

            //System.out.println(fileContents);
            br.close();
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        filterText.setText("");
        targetTerminology.setModel(listModel);
        searchTermWindow.pack();
        searchTermWindow.show();


    }//GEN-LAST:event_findButtonActionPerformed

    private void sourceTermsValueChanged(javax.swing.event.ListSelectionEvent evt) {//GEN-FIRST:event_sourceTermsValueChanged
        if (block) {
            return;
        }
        refreshTargetTerms();
    }//GEN-LAST:event_sourceTermsValueChanged

    private void openFileButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_openFileButtonActionPerformed

        File workingDirectory = new File(System.getProperty("user.dir"));
        final JFileChooser fc = new JFileChooser();
        fc.setCurrentDirectory(workingDirectory);
        int returnVal = fc.showOpenDialog(UI.this);

        if (returnVal == JFileChooser.APPROVE_OPTION) {
            File file = fc.getSelectedFile();
            //This is where a real application would open the file.
            System.out.println("Opening: " + file.getName() + ".");

            currentFile = file.getPath();

            mf = new MappingFile(file.getPath());
            mappings = mf.getMappings();
            refreshSourceTerms();
            saveFileButton.setEnabled(true);
            saveAsButton.setEnabled(true);
        } else {
            System.out.println("Open command cancelled by user.");
        }

    }//GEN-LAST:event_openFileButtonActionPerformed

    private void approveButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_approveButtonActionPerformed

        Mapping curr = mappings.get(sourceTerms.getSelectedIndex());

        String tt = targetTerms.getSelectedValue();
        if (tt == null) {
            tt = "";
        }

        curr.setMappingTerm(tt);
        curr.setMappingStatus(2);
        mappings.set(sourceTerms.getSelectedIndex(), curr);
        refreshSourceTerms();

        sourceTerms.ensureIndexIsVisible(sourceTerms.getSelectedIndex());

        if (autoJumpCheckbox.isSelected()) {
            int k = sourceTerms.getSelectedIndex();
            while (k < mappings.size() && mappings.get(k).getMappingStatus() > 1) {
                k++;
            }
            if (k < mappings.size()) {
                sourceTerms.setSelectedIndex(k);
            }
        }

        sourceTerms.ensureIndexIsVisible(sourceTerms.getSelectedIndex());
    }//GEN-LAST:event_approveButtonActionPerformed

    private void knownButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_knownButtonActionPerformed

        File dir = new File("knownMappings");
        File[] directoryListing = dir.listFiles();
        if (directoryListing != null) {
            for (File child : directoryListing) {
                //System.out.println(child.getAbsolutePath());

                if (child.getAbsolutePath().contains(".known")) {
                    mf = new MappingFile(child.getPath());
                    ArrayList<Mapping> tempMappings = mf.getMappings();

                    for (int a = 0; a < mappings.size(); a++) {
                        for (int b = 0; b < tempMappings.size(); b++) {

                            if (mappings.get(a).getSourceString().toUpperCase().equals(tempMappings.get(b).getSourceString().toUpperCase())
                                    && mappings.get(a).getMappingStatus() != 2) {

                                System.out.println("Found a previously made mapping for: " + mappings.get(a).getSourceString());
                                //System.out.println("                           Which is: " + mappings.get(a).getMappingTerm());

                                for (int c = 0; c < mappings.get(a).getMatchings().size(); c++) {
                                    if (mappings.get(a).getMatchings().get(c).getTargetString().equals(tempMappings.get(b).getMappingTerm())) {
                                        mappings.get(a).setMappingStatus(2);
                                        mappings.get(a).setMappingTerm(tempMappings.get(b).getMappingTerm());
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        refreshSourceTerms();
    }//GEN-LAST:event_knownButtonActionPerformed

    private void revertButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_revertButtonActionPerformed

        Mapping curr = mappings.get(sourceTerms.getSelectedIndex());

        if (!curr.getOriginalMappingTerm().equals("")) {
            curr.setMappingTerm(curr.getOriginalMappingTerm());
            curr.setMappingStatus(1);
            mappings.set(sourceTerms.getSelectedIndex(), curr);
        } else {
            JOptionPane.showMessageDialog(null, "There is no original/suggested mapping to revert to. Please try to find one yourself.", "No suggested mapping.", JOptionPane.INFORMATION_MESSAGE);
        }

        refreshSourceTerms();
        refreshTargetTerms();
    }//GEN-LAST:event_revertButtonActionPerformed

    private void saveFileButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveFileButtonActionPerformed
        MDRPipeConfiguration conf = new MDRPipeConfiguration("default");
        String site = MDRPipeConfiguration.getExportLocation();

        mf.saveMappings(mappings, currentFile, site);
    }//GEN-LAST:event_saveFileButtonActionPerformed

    private void saveAsButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveAsButtonActionPerformed
        MDRPipeConfiguration conf = new MDRPipeConfiguration("default");
        String site = MDRPipeConfiguration.getExportLocation();

        File workingDirectory = new File(System.getProperty("user.dir"));
        final JFileChooser fc = new JFileChooser();
        fc.setCurrentDirectory(workingDirectory);
        int returnVal = fc.showSaveDialog(UI.this);

        if (returnVal == JFileChooser.APPROVE_OPTION) {
            File file = fc.getSelectedFile();
            mf.saveMappings(mappings, currentFile, site);
        } else {
            System.out.println("Save command cancelled by user.");
        }
    }//GEN-LAST:event_saveAsButtonActionPerformed

    private void cancelButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cancelButtonActionPerformed
        searchTermWindow.show(false);
    }//GEN-LAST:event_cancelButtonActionPerformed

    private void filterTextKeyTyped(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_filterTextKeyTyped


    }//GEN-LAST:event_filterTextKeyTyped

    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
        appendToMatches();
    }//GEN-LAST:event_jButton2ActionPerformed

    private void filterTextActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_filterTextActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_filterTextActionPerformed

    private void filterTextKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_filterTextKeyReleased

        DefaultListModel listModel = new DefaultListModel();
        for (int a = 0; a < targetTermList.size(); a++) {
            if (targetTermList.get(a).toUpperCase().contains(filterText.getText().toUpperCase())) {
                listModel.addElement(targetTermList.get(a));
            }
        }
        targetTerminology.setModel(listModel);
    }//GEN-LAST:event_filterTextKeyReleased

    private void targetTerminologyMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_targetTerminologyMouseClicked
        JList list = (JList) evt.getSource();
        if (evt.getClickCount() == 2) {
            int index = list.locationToIndex(evt.getPoint());
            appendToMatches();
        }
    }//GEN-LAST:event_targetTerminologyMouseClicked

    private void statsButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_statsButtonActionPerformed

        int Type0 = 0;
        int Type1 = 0;
        int Type2 = 0;
        int Type3 = 0;
        int Type4 = 0;
        int Type4a = 0;
        int Type4b = 0;
        int Type4c = 0;
        int Type5 = 0;
        int Type6 = 0;
        int Type7 = 0;

        ArrayList<String> t0 = new ArrayList();
        ArrayList<String> t1 = new ArrayList();
        ArrayList<String> t2 = new ArrayList();
        ArrayList<String> t3 = new ArrayList();
        ArrayList<String> t4 = new ArrayList();
        ArrayList<String> t4a = new ArrayList();
        ArrayList<String> t4b = new ArrayList();
        ArrayList<String> t4c = new ArrayList();
        ArrayList<String> t5 = new ArrayList();
        ArrayList<String> t6 = new ArrayList();
        ArrayList<String> t7 = new ArrayList();

        String statTable = "LOCATION;TYPE;SOURCE STRING;TOP SUGGESTION;CORRECTED MAPPING\n";

        for (int a = 0; a < mappings.size(); a++) {
            Mapping mapping = mappings.get(a);
            ArrayList<Match> matches = mapping.getMatchings();

            if (mapping.getMappingStatus() < 2) {

                Type0++;
                t0.add("No mapping approved for: '" + mapping.getSourceString() + "'");

                statTable += "SITE;0;" + mapping.getSourceString() + ";" + ";\n";

            } else {

                int mapX = -1;
                int mapOrigX = -1;
                String mScore = "";

                boolean hasEquivalent = false;
                boolean createdMapping = false;
                boolean isCorrect = false;
                boolean amongMatches = false;

                for (int b = 0; b < matches.size(); b++) {
                    if (matches.get(b).getMap().equals("X")) {
                        mapX = b;
                        mScore = matches.get(b).getScore();
                    }
                    if (matches.get(b).getOriginalMap().equals("X")) {
                        mapOrigX = b;
                        mScore = matches.get(b).getScore();
                    }
                }
                if (mapX > -1) {
                    hasEquivalent = true;
                }
                if (mapOrigX > -1) {
                    createdMapping = true;
                }
                if (mapX == mapOrigX && !mScore.trim().toUpperCase().equals("MANUAL")) {
                    isCorrect = true;
                }
                if (!mScore.trim().toUpperCase().equals("MANUAL") && mapX > -1) {
                    amongMatches = true;
                }
                if (!hasEquivalent && !createdMapping && isCorrect && !amongMatches) {

                    Type1++;
                    t1.add("No equivalent in target for: '" + mapping.getSourceString() + "'");
                    statTable += "SITE;1;" + mapping.getSourceString() + ";" + ";\n";

                } else if (!hasEquivalent && createdMapping && !isCorrect && !amongMatches) {

                    Type2++;
                    t2.add("   No equivalent in target for: '" + mapping.getSourceString() + "'\n"
                            + "first top-score suggestion was: '" + matches.get(0).getTargetString() + "'\n");

                    statTable += "SITE;2;" + mapping.getSourceString() + ";" + matches.get(0).getTargetString() + ";\n";

                } else if (hasEquivalent && !createdMapping && !isCorrect && !amongMatches) {

                    Type3++;
                    t3.add("        No mapping created for: '" + mapping.getSourceString() + "'\n"
                            + "first top-score suggestion was: '" + matches.get(0).getTargetString() + "'\n"
                            + "        the correct mapping is: '" + matches.get(mapX).getTargetString() + "'\n");

                    statTable += "SITE;3;" + mapping.getSourceString() + ";" + matches.get(0).getTargetString() + ";" + matches.get(mapX).getTargetString() + "\n";

                } else if (hasEquivalent && !createdMapping && !isCorrect && amongMatches) {

                    Type4++;
                    t4.add("        No mapping created for: '" + mapping.getSourceString() + "'\n"
                            + "first top-score suggestion was: '" + matches.get(0).getTargetString() + "'\n"
                            + "        the correct mapping is: '" + matches.get(mapX).getTargetString() + "'\n"
                    );

                    statTable += "SITE;4;" + mapping.getSourceString() + ";" + matches.get(0).getTargetString() + ";" + matches.get(mapX).getTargetString() + "\n";

                    if (mapX == 0) {
                        Type4a++;
                        t4a.add("        No mapping created for: '" + mapping.getSourceString() + "'\n"
                                + "first top-score suggestion was: '" + matches.get(0).getTargetString() + "'\n"
                                + "        the correct mapping is: '" + matches.get(mapX).getTargetString() + "'\n");
                        statTable += "SITE;4A;" + mapping.getSourceString() + ";" + matches.get(0).getTargetString() + ";" + matches.get(mapX).getTargetString() + "\n";

                    } else if (mScore.equals(matches.get(0).getScore())) {
                        Type4b++;
                        t4b.add("        No mapping created for: '" + mapping.getSourceString() + "'\n"
                                + "first top-score suggestion was: '" + matches.get(0).getTargetString() + "'\n"
                                + "        the correct mapping is: '" + matches.get(mapX).getTargetString() + "'\n");
                        statTable += "SITE;4B;" + mapping.getSourceString() + ";" + matches.get(0).getTargetString() + ";" + matches.get(mapX).getTargetString() + "\n";

                    } else {
                        Type4c++;
                        t4c.add("        No mapping created for: '" + mapping.getSourceString() + "'\n"
                                + "first top-score suggestion was: '" + matches.get(0).getTargetString() + "'\n"
                                + "        the correct mapping is: '" + matches.get(mapX).getTargetString() + "'\n");
                        statTable += "SITE;4C;" + mapping.getSourceString() + ";" + matches.get(0).getTargetString() + ";" + matches.get(mapX).getTargetString() + "\n";

                    }

                } else if (hasEquivalent && createdMapping && !isCorrect && !amongMatches) {
                    Type5++;
                    t5.add("Wrong mapping created for: '" + mapping.getSourceString() + "'\n"
                            + "    the wrong mapping was: '" + matches.get(0).getTargetString() + "'\n"
                            + "   the correct mapping is: '" + matches.get(mapX).getTargetString() + "'\n");
                    statTable += "SITE;5;" + mapping.getSourceString() + ";" + matches.get(0).getTargetString() + ";" + matches.get(mapX).getTargetString() + "\n";

                } else if (hasEquivalent && createdMapping && !isCorrect && amongMatches) {
                    Type6++;
                    t6.add("Wrong mapping created for: '" + mapping.getSourceString() + "'\n"
                            + "    the wrong mapping was: '" + matches.get(0).getTargetString() + "'\n"
                            + "   the correct mapping is: '" + matches.get(mapX).getTargetString() + "'\n");
                    statTable += "SITE;6;" + mapping.getSourceString() + ";" + matches.get(0).getTargetString() + ";" + matches.get(mapX).getTargetString() + "\n";

                } else if (hasEquivalent && createdMapping && isCorrect && amongMatches) {
                    Type7++;
                    t7.add("Correct mapping created for: '" + mapping.getSourceString() + "'\n"
                            + "  the automatic mapping was: '" + matches.get(0).getTargetString() + "'\n"
                            + "     the correct mapping is: '" + matches.get(mapX).getTargetString() + "'\n");
                    statTable += "SITE;7;" + mapping.getSourceString() + ";" + matches.get(0).getTargetString() + ";" + matches.get(mapX).getTargetString() + "\n";

                } else {
                    System.out.println("Don't know how to classify:");
                    System.out.println(" hasEquivalent: " + hasEquivalent);
                    System.out.println(" createdMapping: " + createdMapping);
                    System.out.println(" isCorrect: " + isCorrect);
                    System.out.println(" amongMatches: " + amongMatches);
                    System.out.println("");
                    System.out.println(" Source Term: " + mapping.getSourceString());
                    System.out.println(" Suggested: " + matches.get(0).getTargetString());
                    if (mapX > -1) {
                        System.out.println(" Corrected: " + matches.get(mapX).getTargetString());
                    } else {
                        System.out.println(" Corrected: NO MAPPING");
                    }
                    System.out.println(" Score: " + mScore.trim());
                    System.exit(0);
                }
            }
        }

        String statFile = "";

        statFile += "\n" + ("Statistics about automatic mapping quality:\n");

        statFile += "\n" + (" Type 0: " + Type0);
        statFile += "\n" + (" Type 1: " + Type1);
        statFile += "\n" + (" Type 2: " + Type2);
        statFile += "\n" + (" Type 3: " + Type3);
        statFile += "\n" + (" Type 4: " + Type4);
        statFile += "\n" + ("Type 4A: " + Type4a);
        statFile += "\n" + ("Type 4B: " + Type4b);
        statFile += "\n" + ("Type 4C: " + Type4c);
        statFile += "\n" + (" Type 5: " + Type5);
        statFile += "\n" + (" Type 6: " + Type6);
        statFile += "\n" + (" Type 7: " + Type7);
        statFile += "\n" + ("");

        statFile += "\n" + ("\n=========== Type 0: Mapping was not approved by the user. ===========\n");

        for (int c = 0; c < t0.size(); c++) {
            statFile += "\n" + (t0.get(c));
        }

        statFile += "\n" + ("\n=========== Type 1: No mapping was created, which is correct because there's no equivalent item in the target terminology. ===========\n");

        for (int c = 0; c < t1.size(); c++) {
            statFile += "\n" + (t1.get(c));
        }

        statFile += "\n" + ("\n=========== Type 2: A mapping was created, which is wrong, because there's no equivalent item in the target terminology. ===========\n");

        for (int c = 0; c < t2.size(); c++) {
            statFile += "\n" + (t2.get(c));
        }

        statFile += "\n" + ("\n=========== Type 3: No mapping was created, but should have been. Additionally the correct term was not in the list of proposals. ===========\n");

        for (int c = 0; c < t3.size(); c++) {
            statFile += "\n" + (t3.get(c));
        }

        statFile += "\n" + ("\n=========== Type 4A: No mapping was created, but should have been. The correct term was the first top-score proposal. ===========\n");

        for (int c = 0; c < t4a.size(); c++) {
            statFile += "\n" + (t4a.get(c));
        }

        statFile += "\n" + ("\n=========== Type 4B: No mapping was created, but should have been. The correct term was one of the other top-score proposals. ===========\n");

        for (int c = 0; c < t4b.size(); c++) {
            statFile += "\n" + (t4b.get(c));
        }

        statFile += "\n" + ("\n=========== Type 4C: No mapping was created, but should have been. The correct term was one of the lower-score proposals. ===========\n");

        for (int c = 0; c < t4c.size(); c++) {
            statFile += "\n" + (t4c.get(c));
        }

        statFile += "\n" + ("\n=========== Type 5: A wrong mapping was created. The correct one was not in the list of proposals. ===========\n");

        for (int c = 0; c < t5.size(); c++) {
            statFile += "\n" + (t5.get(c));
        }

        statFile += "\n" + ("\n=========== Type 6: A wrong mapping was created. The correct one was in the list of proposals. ===========\n");

        for (int c = 0; c < t6.size(); c++) {
            statFile += "\n" + (t6.get(c));
        }

        statFile += "\n" + ("\n=========== Type 7: A correct mapping was created. ===========\n");

        for (int c = 0; c < t7.size(); c++) {
            statFile += "\n" + (t7.get(c));
        }

        MDRPipeConfiguration conf = new MDRPipeConfiguration("default");
        String site = MDRPipeConfiguration.getExportLocation();

        PrintWriter writer;
        try {
            writer = new PrintWriter(site + " Statistics.txt", "UTF-8");
            writer.println(statFile.replaceAll("\n", "\r\n"));
            writer.close();
            java.awt.Desktop.getDesktop().edit(new File(site + " Statistics.txt"));
        } catch (Exception ex) {
            Logger.getLogger(UI.class.getName()).log(Level.SEVERE, null, ex);
        }

        try {
            writer = new PrintWriter(site + " Statistics.csv", "UTF-8");
            writer.println(statTable.replaceAll("\n", "\r\n").replaceAll("SITE", site));
            writer.close();
        } catch (Exception ex) {
            Logger.getLogger(UI.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_statsButtonActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */

        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }

        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(UI.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);

        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(UI.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);

        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(UI.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);

        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(UI.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new UI().setVisible(true);

            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton approveButton;
    private javax.swing.JCheckBox autoJumpCheckbox;
    private javax.swing.JButton cancelButton;
    private javax.swing.JTextField filterText;
    private javax.swing.JButton findButton;
    private javax.swing.JButton jButton2;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JButton knownButton;
    private javax.swing.JLabel logo;
    private javax.swing.JButton openFileButton;
    private javax.swing.JButton removeMappingButton;
    private javax.swing.JButton revertButton;
    private javax.swing.JButton saveAsButton;
    private javax.swing.JButton saveFileButton;
    private javax.swing.JFrame searchTermWindow;
    private javax.swing.JList<String> sourceTerms;
    private javax.swing.JButton statsButton;
    private javax.swing.JList<String> targetTerminology;
    private javax.swing.JList<String> targetTerms;
    // End of variables declaration//GEN-END:variables

    private void refreshSourceTerms() {

        if (mappings == null) {
            return;
        }

        sourceTerms.removeAll();

        block = true;

        int selected = sourceTerms.getSelectedIndex();

        DefaultListModel listModel = new DefaultListModel();
        for (int a = 0; a < mappings.size(); a++) {

            //if (hideApprovedCheckbox.isSelected() && mappings.get(a).getMappingStatus() != 2) {
            //    listModel.addElement(mappings.get(a).getSourceString());
            //}
            //if (!hideApprovedCheckbox.isSelected()) {
            listModel.addElement(mappings.get(a).getSourceString());
            //}

        }
        sourceTerms.setModel(listModel);
        ColorCellRenderer csr = new ColorCellRenderer();
        sourceTerms.setCellRenderer(csr);

        for (int a = 0; a < mappings.size(); a++) {
            int status = mappings.get(a).getMappingStatus();
            if (status == 0) {
                csr.setBackgroundColor(a, new Color(255, 190, 190));
                csr.setFontColor(a, new Color(255, 0, 0));
            }
            if (status == 1) {
                csr.setBackgroundColor(a, new Color(255, 255, 190));
                csr.setFontColor(a, new Color(255, 255, 0));
            }
            if (status == 2) {
                csr.setBackgroundColor(a, new Color(190, 255, 190));
                csr.setFontColor(a, new Color(0, 255, 0));
            }
        }

        sourceTerms.setSelectedIndex(selected);

        block = false;

        refreshInfo();

        if (sourceTerms.isSelectionEmpty()) {
            sourceTerms.setSelectedIndex(0);
        }

    }

    private void refreshTargetTerms() {
        int selected = -1;

        int selectedIndex = sourceTerms.getSelectedIndex();
        String selectedSourceTerm = mappings.get(sourceTerms.getSelectedIndex()).getSourceString();
        int mappingStatus = mappings.get(sourceTerms.getSelectedIndex()).getMappingStatus();
        String targetTerm = mappings.get(sourceTerms.getSelectedIndex()).getMappingTerm();
        String origMapp = mappings.get(sourceTerms.getSelectedIndex()).getOriginalMappingTerm();

        System.out.println("Selected index: " + selectedIndex);
        System.out.println("Selected source term: " + selectedSourceTerm);
        System.out.println("Mapping status: " + mappingStatus);
        System.out.println("Target term: " + targetTerm);
        System.out.println("Original mapping: " + origMapp);
        System.out.println();

        targetTerms.clearSelection();

        for (int a = 0; a < mappings.size(); a++) {
            if (sourceTerms.getSelectedValue().equals(mappings.get(a).getSourceString())) {
                ArrayList<Match> matchings = mappings.get(a).getMatchings();
                DefaultListModel listModel = new DefaultListModel();
                for (int b = 0; b < matchings.size(); b++) {
                    listModel.addElement(matchings.get(b).getTargetString());
                    //if (matchings.get(b).getTargetString().equals(mappings.get(a).getMappingTerm())) {
                    //if (matchings.get(b).getMap().equals("X")) {
                    if (matchings.get(b).getTargetString().equals(mappings.get(a).getMappingTerm())) {
                        System.out.println("Selecting: " + mappings.get(a).getMappingTerm());
                        selected = b;
                    }
                }
                targetTerms.setModel(listModel);
                if (selected >= 0) {
                    targetTerms.setSelectedIndex(selected);
                }
            }
        }

        refreshInfo();

    }

    private void refreshInfo() {

        /*
        if (sourceTerms.getSelectedValue() == null || sourceTerms.getSelectedValue() == null) {
            return;
        }
        if (sourceTerms.getSelectedValue().equals("") || sourceTerms.getSelectedValue().equals("")) {
            return;
        }
        
        sourceConcept.setText(sourceTerms.getSelectedValue());
        targetConcept.setText(targetTerms.getSelectedValue());
         */
    }

    private void appendToMatches() {

        if (!targetTerminology.isSelectionEmpty()) {
            Mapping currentMapping = mappings.get(sourceTerms.getSelectedIndex());
            ArrayList<Match> currentMatchings = currentMapping.getMatchings();
            Match newMatch = new Match("MANUAL", "X", "", targetTerminology.getSelectedValue());
            currentMatchings.add(newMatch);
            currentMapping.setMatchings(currentMatchings);
            mappings.set(sourceTerms.getSelectedIndex(), currentMapping);
            refreshTargetTerms();
            targetTerms.setSelectedIndex(targetTerms.getModel().getSize() - 1);
        }
        searchTermWindow.show(false);
    }
}
